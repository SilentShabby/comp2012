# COMP2012 Study Notes

COMP2012	**Object-Oriented Programming and Data Structures**  
2018 Spring, HKUST

Programs on GitHub: [gerald-liu/comp2012](https://github.com/gerald-liu/comp2012)

Notes by **Gerald Liu**  
[wliuax@connect.ust.hk](mailto:wliuax@connect.ust.hk)

**Table of Contents**

- [Object-Oriented Programming](#h1)
  - [Basic Knowledge](#h1.1)
  - [Constructor and Destructor](#h1.2)
  - [Inheritance](#h1.3)
  - [Generic Programming](#h1.4)
  - [rvalue Reference](#h1.5)
  - [Static](#h1.6)
- [Data Structures](#h2)
  - [Binary Search Tree](#h2.1)
  - [Hashing](#h2.2)

<a name="h1"/>

## Object-Oriented Programming

<a name="h1.1"/>

### Basic Knowledge

- `const` to the left of the `∗` &rArr; pointer to const  
  `const` to the right of the `∗` &rArr; const pointer  
  (read from right to left)
- `const` member functions cannot call non-const member functions
- Access:
  - `public` : everything
  - `protected` : member functions and friends of **the class and derived classes**
  - `private` : member functions and friends of **the class**
    - no access even for private inherited classes!
    - a base class must have non-private constructor/destructor

<a name="h1.2"/>

### Constructor and Destructor

- Brace initializer `= {}` : if data members are **all public** (illegal when any constructor is defined)

  ```c++
  class Word { public: int f; const char* s; Word(int f, const char* s) {} };

  Word movie = {1, "Titanic"}; // illegal
  ```

- A default constructor is automatically supplied only when **no user-defined constructor** is found!

  ```c++
  //Word;			// Compilation Error: declaration does not declare anything
  Word();			// initialization with default constructor, POOR GUY
  Word w;			// initialization with default constructor
  Word w0();		// function declaration with name "w0" and return type Word: type 'Word()'
  Word w1{};		// initialization with default constructor
  ```
  A default copy constructor is automatically supplied only when no wrong copy constructor is found!

  ```c++
  class P { public: P(P& p) {} };

  const P r;
  P s(r); // Error: binding ‘const P’ to reference of type ‘P&’ discards qualifiers
  ```

- A conversion constructor is a constructor accepting a **single argument**, or all but one argument have default values.

  **implicit conversion** calls **conversion** (for the temporary object) and **move** constructors!

  ```c++
  explicit Word(const char* s); // to disallow implicit conversion

  Word movie0 {'A'}; // Explicit conversion
  Word movie1 = 'B'; // Implicit conversion: Error!
  ```

- A copy constructor `X::X(const X&)` is called when:

  - parameter **passed by value**
  - object **returned by value**
  - **initialization using assignment** syntax (e.g. `Word y = x;`)

  ```c++
  Word(const Word& w) : freq(w.freq), str(new char [strlen(w.str)+1]) { // deep copy
      strcpy(str, w.str); }

  void operator=(const Word& w) {
      if (this != &w) {
          delete [] str;				  	   // delete dynamic data of this
          str = new char [strlen(w.str)+1];	// deep copy
          freq = w.freq; strcpy(str, w.str);
      }
  }
  ```

  default copy: memberwise copy, no **dynamic memory allocation** (shallow copy, potential dangling)

  - for default assignment: plus no **dynamic memory deallocation** in this object 

  if "&" is left out, the calling of copy will cause compilation error (infinite recursion of copying when PBV)

  ```c++
  void Bug(Word& x) { Word bug("bug", 4); x = bug; } // memory leak of x (movie)

  Word movie {"Titanic"};
  Bug(movie);	// memory leak of movie; and the Word{"bug", 4} is deleted right afterwards
  return 0;	// ~Word() cannot delete dangling pointer
  ```

- default argument

  - **specified only once** (usually in header, not in definition)!
  - for multiple default args, provide them in the order in definition (e.g. for `A(int a = 1, int b = 2)`, `A(5)` is equivalent to `A(5, 2)`)

- **const or reference members** must be initialized using **member initialization list!**  
  It **cannot be done using default arguments**!

- The default destructor simply releases the memory in stack!

- To explicitly generate or not generate a constructor/destructor: `= default`; `= delete`;

- Order of construction:

  1. **base** class

  2. data **members** (in the **order of declaration**)

     ```c++
     class Word_Pair { 
     private: Word w1; Word w2;
     public: Word_Pair(const char* s1, const char* s2) : w2(s2), w1(s1,5) {} };
     // w1 is created first, and then w2
     ```

  3. **itself**

  Destruction: in the reverse order (use delete properly in the destructors!)


<a name="h1.3"/>

### Inheritance

- Types of inheritance

  - `public` : preserves original accessibility
  - `protected` : makes `public` and `protected` members **protected**
  - `private` : makes everything **private**

- Constructors and destructors are never inherited

- Slicing: only for **public inheritance**

  ```c++
  Base base;
  base = derived; 	// Slicing

  Base b = derived;	// Initializing with copy constructor
  Base* b = &derived; // Can't use derived-class specific members
  Base& b = derived;	// Can't use derived-class specific members

  // The following assignments give compilation errors:
  //derived = base;		// Unless it's user-defined
  //Derived* d = &base; 	// No such conversion!
  //Derived& d = base;	// No such conversion!
  ```

- `virtual`

  - member functions: virtual in the base class, **virtual in all derived classes**

  - destructor: must be virtual for **base class**

  - if `virtual` is not used, under `Base b = new Derived`,  
    `Base::foo()` will be called instead of `Derived::foo()`

  - if a virtual `foo()` is called inside `Base` constructor/destructor, it represents `Base::foo()`  
    (because `Derived::foo()` has not been created / already been deleted)

  - pure virtual functions `void foo() = 0;` : only in an abstract base class

  - dynamic binding: only works on a **pointer or reference**

    ```c++
    class A { public: virtual void f() { cout << "func in A" << endl; } };
    class B : public A { private: virtual void f() { cout << "func in B" << endl; } };

    B bObj;
    //bObj.f(); 	// Error: func() in B is private
    A& aRef = bObj; // Liscov substitution principle

    aRef.f(); 	// We can call func() in B via dynamic binding, even it is private
    // Type of aRef is A, so we should first reach func() in A
    // f() in A is virtual, so we check and find the object aRef refers to is B type
    // f() in B is called, despite that it's private
    ```

  - **dynamic_cast**\<Class_Name\*>(obj\* / obj&)  

    - only works on **pointers and references** of polymorphic class (with virtual functions) types
    - if the conversion cannot be done (e.g. base to derived), NULL will be returned

- Abstract Base Class (ABC)

  - **No objects** of ABC can be created (pointer or reference types are allowed)
  - Its derived classes must implement the **pure virtual** functions, otherwise they will also be ABCs
  - cannot be used as:
    - argument type that is passed by value
    - return type that is returned by value
    - type of an explicit conversion

- `final`

  ```c++
  class Student final : public UPerson { // No sub-classes can be derived from a final class
  	public: /* Other data and functions */
      // a final virtual function cannot be overridden any more
  	virtual void print() const override final {} 
  };
  ```

<a name="h1.4"/>

### Generic Programming

```c++
template <typename T, typename U>
class A() { public: foo(); };

template <typename T, typename U>
A<T, U>::foo() {}

int main() { A<int, double> a; a.foo(); }
// always specify actual template arguments when creating template class objects
```

- **no automatic type conversion** for template arguments! (e.g. `T foo(T& a, T& b)` will raise an error on `foo(1, 1.5)` )

- operator overloading cannot change arity, associativity, and precedence.

- member operator: **not commutative** (so global operator is better)

- `operator+(a, b)` and  `a.operator+(b)` : error to define both!

- assignment `operator=` : check `this != &a` to **avoid self-assignment**!

- using copy assignment (or equivalents like `this->set(const A&)`) in constructor: set pointers to dynamic data to `nullptr` ! (because `delete` in copy assignment may have bad access!)

- `operator[]` and `operator++`

  ```c++
  double operator[](int) const; // Read-only; c.f. getx() and gety()
  double& operator[](int); 	 // Allow read and write
  Vector& operator++(); 		 // Pre-increment returns an l-value
  Vector operator++(int);		 // Post-increment returns a r-value
  ```

- `friend`

  ```c++
  class A {
      friend ostream& operator<<(ostream& os, const A& a) { os << a.data; } // cascade outputs
      friend class B; // B can access all members of A; No forward declaration of B is needed
  private: int data;
  };
  ```

  not symmetric, not transitive, not inherited


<a name="h1.5"/>

### rvalue Reference

- Temporary objects: created on the stack

  - RBV: use move construction if it has been defined by user, else use copy construction

  ```c++
  const Word& w0 = "w0";
  // const lvalue ref initialization: can take both lvalue and rvalue
  // TO = Word("w0") [conversion];
  // bind w0 (const lvalue ref) to TO (rvalue), so TO is not killed now
  // or similarly: Word&& w00 = "w00"; bind w00 (rvalue ref) to TO (rvalue)

  Word w1("w1"); Word w2("w2"); // [conversion]*2
  Word w3 = w1 + " or " + w2;
  // result of sub-expressions: (w1+" or "), (w1+" or "+w2)

  // argument passing with conversion: Word(const char*)
  // TO1 = Word(" or ") [conversion];

  // function return by value: Word Word::operator+(const Word&)
  // TO_local = Word(*this) [copy]; TO2 = w1 + " or " [move]; [destruct] TO_local
  // TO_local = Word(*this) [copy]; TO3 = TO2 + w2 [move]; [destruct] TO_local

  // w3 = Word(TO3) [move]; [destruct]*3 TO1, TO2, TO3

  Word& w5 = w3; // lvalue ref takes rvalue ref as lvalue
  Word& w6 = "w6"; // Error: lvalue ref only takes lvalue

  return; // [destruct]*4 w0 (i.e. TO), w1, w2, w3
  ```

- A rvalue reference cannot bind to a new temporary object once initialized;  
  A rvalue reference cannot be assigned from another rvalue reference.

- functions taking **rvalue ref** (e.g. move constructor) only takes **temporary objects**!

  ```c++
  void print(const int& i);  // takes all kinds
  void print(int&& i);	  // only takes TO

  print(1); // int TO = 1; prefer print(int&&)

  int i = 1; 					// object on stack
  int* p = new int; *p = 1; 	 // object on heap
  int&& r = 1; 				// rvalue ref

  print(i); print(*p); print(r); // 'int' as lvalue, call print(const int&)
  print(move(i)); print(move(*p)); print(move(r)); // cast to TO (int&&), call print(int&&)
  ```

- move constructor and assignment operator

  ```c++
  Word(Word&& w) : freq(w.freq), str(w.str) {
      w.freq = 0; w.str = nullptr; }	   // nullify the pointers in TO

  void operator=(Word&& w) {
      if (this != &w) {
          delete [] str;				  // delete dynamic data of this
          freq = w.freq; str = w.str; 
          w.freq = 0; w.str = nullptr;   // nullify the pointers in TO
      }
  }
  ```

  default move constructor: memberwise move, no reset-to-0 or **nullify** (bad access when `delete`!)

  - for default assignment: plus no **dynamic memory deallocation** in this object

<a name="h1.6"/>

### Static



<a name="h2"/>

## Data Structures

<a name="h2.1"/>

### Binary Search Tree



<a name="h2.2"/>

### Hashing

